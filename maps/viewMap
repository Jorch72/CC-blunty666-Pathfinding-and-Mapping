local tArgs = {...}

local function printUsage()
	print("Usages:")
	print("viewMap <(string) mapAPIPath> <(string) mapName>")
	print("viewMap <(string) mapAPIPath> <(string) mapName> <(int) x-coord> <(int) y-coord> <(int) z-coord>")
	print("mapName must be the complete file path")
end

local mapAPIPath = tArgs[1]
if not mapAPIPath or type(mapAPIPath) ~= "string" or not fs.exists(mapAPIPath) or fs.isDir(mapAPIPath) then
	error("invalid mapAPIPath: "..tostring(mapAPIPath))
end
local mapAPI = fs.getName(mapAPIPath)
if not _G[mapAPI] then
	if not os.loadAPI(mapAPIPath) then
		error("could not load mapAPI: "..tostring(mapAPIPath))
	end
end
mapAPI = _G[mapAPI]

local map
local mapName = tArgs[2]
if mapName and type(mapName) == "string" and fs.exists(mapName) and fs.isDir(mapName) then
	map = mapAPI.new(mapName)
	if not map then
		error("could not load map at "..mapName)
	end
else
	printUsage()
end

local startX, startY, startZ
if #tArgs == 5 then
	for i = 3, 5 do
		local num = tArgs[i]
		if not tonumber(num) or num % 1 ~= 0 then
			printUsage()
			return
		end
	end
	startX = tArgs[3]
	startY = tArgs[4]
	startZ = tArgs[5]
end

if not startX then
	map:loadAll()
	--find any point on map that isn't empty
end

term.setCursorBlink(false)
term.setBackgroundColour(colours.black)

local cont = true
local width, height = term.getSize()
local currW, currH = 1, 1
term.setCursorBlink(true)
term.setTextColour(colours.red)
local redraw = true
while cont do
	if redraw then
		term.setBackgroundColour(colours.black)
		term.clear()
		term.setCursorPos(1, height)
		term.clearLine()
		term.write(tostring(startX + currW - 1)..","..tostring(startY)..","..tostring(startZ + currH - 1))
		term.write(" -- ")
		term.write(tostring(math.floor( (startX + currW - 1)/16 )))
		term.write(",")
		term.write(tostring(math.floor( (startY)/16 )))
		term.write(",")
		term.write(tostring(math.floor( (startZ + currH - 1)/16 )))
		for x = 1, width do
			for z = 1, height - 1 do
				local value = map:get(vector.new(startX + x - 1, startY, startZ + z - 1))
				if value then
					term.setBackgroundColour(colours.white)
					term.setCursorPos(x, z)
					term.write(string.sub(value, 1, 1))
				end
			end
		end
		term.setCursorPos(currW, currH)
		redraw = false
	end
	local event = {os.pullEvent()}
	if event[1] == "key" then
		local key = event[2]
		if key == keys.up then
			startZ = startZ - 1
		elseif key == keys.down then
			startZ = startZ + 1
		elseif key == keys.left then
			startX = startX - 1
		elseif key == keys.right then
			startX = startX + 1
		elseif key == keys.numPadAdd then
			startY = startY + 1
		elseif key == keys.numPadSubtract then
			startY = startY - 1
		elseif key == keys.backspace then
			cont = false
		end
		redraw = true
	elseif event[1] == "mouse_click" then
		if event[4] < height then
			currW, currH = event[3], event[4]
			term.setCursorPos(1, height)
			term.clearLine()
			term.write(tostring(startX + currW - 1)..","..tostring(startY)..","..tostring(startZ + currH - 1))
			term.write(" -- ")
			term.write(tostring(math.floor( (startX + currW - 1)/16 )))
			term.write(",")
			term.write(tostring(math.floor( (startY)/16 )))
			term.write(",")
			term.write(tostring(math.floor( (startZ + currH - 1)/16 )))
			term.setCursorPos(currW, currH)
		end
	elseif event[1] == "term_resize" then
		width, height = term.getSize()
		redraw = true
	end
end

term.setBackgroundColour(colours.black)
term.setCursorPos(1, 1)
term.clear()